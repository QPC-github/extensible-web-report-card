{"name":"Extensible Web Report Card","tagline":"Documenting the state of the extensible web","body":"# Extensible Web Report Card\r\n\r\nCriteria\r\n----------\r\n\r\n- How well does a particular specification or technology implement the extensibility approach outlined in the Extensible Web Manifesto?\r\n- Has the spec exposed a low-level capabiloty?\r\n- Does the spec have a good layering story?\r\n\r\nOverall Discussion\r\n-------------------------\r\n\r\nThe process of archealogy to extension. Working top-down vs. bottom-up (both have advantages and disadvantages).\r\n\r\nSome web specs intentionally delegate behavior to the OS (scroll, look of form controls, etc.) and this is a good thing. However, it may have the effect of\r\nmaking it hard to define extensibility points. When we don't define them, people end up rebuilding the stack, often in a way that works poorly outside of\r\nthe OS they were copying.\r\n\r\nWhen you make a new spec that is related (either higher or lower level) to an existing feature, you should explicitly think and describe in the spec how they are connected to each other.\r\n\r\nPlays Well With Others\r\n-------------------------------\r\n\r\n### Service worker!\r\n\r\n### asm.js\r\n\r\nFast code is enabling. There are things you simply cannot do without good performance (games, codecs).\r\n\r\nWhen JS was slow, it was hard to build even basic abstractions. The next frontier was low-level memory management via ArrayBuffer. The final frontier was across-the-board native performance via asm.js.\r\n\r\n### Custom elements\r\n\r\nExplains how the parser generates a DOM tree of JavaScript objects from a stream of HTML text.\r\n\r\n### `<template>`\r\n\r\nExposes HTML fragment parsing and ability to parse without executing.\r\n\r\n### Mutation observers\r\n\r\nExplains browser behavior WRT reacting to DOM changes; e.g. for layout/paint invalidation.\r\n\r\nNot unified with Object.observe(). The attribute/property split makes it so we can't have nice things.\r\n\r\n### URL Parsing API\r\n\r\nBefore, this was locked up in the process of creating `<a>` and `<base>` tags, setting their `href`, and then seeing what happens after they go back to the browser's code and do their thing. Now, there is an actual API that exposes relative and absolute [URL parsing](https://url.spec.whatwg.org/#api).\r\n\r\n### Push API\r\n\r\n### Explaining the DOM via JavaScript\r\n\r\nProxies, weak maps, getters and setters. Pretty much everything except `document.all`'s falsey-object behavior -- which needs to die in a fire. The shift from \"host object\" in ES5 to \"exotic object\" in ES6\r\n\r\nIs Disruptive In Class\r\n----------------------------\r\n\r\n### registerProtocolHandler\r\n\r\nA good device capability to expose, but not enough implementations!\r\n\r\n### Performance Metrics\r\n\r\nWe have some loading time APIs (resource timing, navigation timing), but e.g. no FPS measurement API. (Link to talks.)\r\n\r\n### Shadow DOM\r\n\r\nDoesn't actually explain the platform's shadow DOM due to lack of encapsulation and inability to negotiate layout between the component and its surroundings -- similar issue to <iframe seamless> and x-origin content.\r\n\r\nConflates selector matching, CSS inheritance, and event retargeting isolation boundaries into a single primitive\r\n\r\nNeed e.g. custom pseudo-elements as a way of exposing standardized styling hooks, both for developer-created controls and for standard controls like `<details>` or `<input type=\"date\">`.\r\n\r\n### Audio\r\n\r\nThe fact web audio exists is awesome compared to just having `<audio>`. But layering story is not yet good, both within web audio and how it relates to `<audio>`.\r\n\r\nE.g., how does Web Audio related to the default output context for a page? How does it relate to <audio> and <video>? Can we implement `PannerNode` as code on top of some kind of scriptable audio node?\r\n\r\n### Object.observe\r\n\r\nGood primitive, helps explain things. Lack of implementations is holding it back.\r\n\r\n### Intention Events\r\n\r\nAbility to understand a platform-specific, high-level intention like \"paste\", vs. having to reverse-engineer from the specific keyboard events that occurred. This can be especially problematic because the intent can be triggered in different ways in different platforms (or via screen readers etc.). An easy example is how on Windows undo is Ctrl+Z; on Mac it is Cmd+Z; on iOS it is shaking your device up and down.\r\n\r\nThere is also a problem of not knowing exactly how an element was focused (keyboard focus should show a visual indicator, but mouse should not, and the details may be different per platform).\r\n\r\nRuns with Scissors\r\n-------------------------\r\n\r\n### Forms\r\n\r\nForms have a lot of problems. E.g. FormData lacks serialization; we have no filepicker API to get the binary blobs from the user's filesystem ourselves; custom elements cannot participate in form submission or get into `form.elements`; validation rules (and UI) are fixed and non-extensible. There are many CSS pseudoselectors having to do with forms that custom elements cannot make match themselves, e.g. `:readonly`, `:valid`/`:invalid`, ...\r\n\r\n### Codecs\r\n\r\nImages, audio, video -- all are locked away, both decoding and encoding. Need off-main-thread APIs; e.g. explained via workers. Similarly timing about when/where to do image decodes is not exposed making it difficult to efficiently polyfill `<img>`.\r\n\r\n### CSS, Layout, and Rendering\r\n\r\nIn general quite poor. Painting algorithm is composed of 12 secret steps that you can't participate in even though we have a bitmap drawing system in the platform (<canvas>). Line breaking is not exposed. Font data is not exposed. RTL decisions are not exposed. Very little control over text quality. No ability to override FOUC/FOUF policies. No extensibility in selectors or media queries. No direct script access to the layer tree. No direct script access to the quad box trees that are generated for 3d transforms. No ability to create a new layout mode.\r\n\r\nCSS OM is...low-level in all the wrong ways.\r\n\r\nThere are glimmers of hope: the Web Animations spec attempts to explain and unify the platform's various animations (e.g. CSS animations, CSS transitions, and SVG), although exactly how this works is still being specced (TODO: link to the open bugs). The CSSWG has recently agreed to try speccing the box tree, which is foundational to how layout works. And the [\"CSS Extensions\"](http://tabatkins.github.io/specs/css-aliases/) editor's draft gives us a path toward custom selectors, combinators, at-rules, and functions---in short, making CSS extensions prolyfillable.\r\n\r\n### Editing (`contenteditable`)\r\n\r\n`contenteditable` is the epitome of a non-extensible high-level API that tries to do too much, and forces developers to reinvent most of it when it fails for their particular use case. Posts like [\"Why ContentEditable is Terrible, Or: How the Medium Editor Works\"](https://medium.com/medium-eng/why-contenteditable-is-terrible-122d8a40e480) explain this in depth. There are efforts to reform `contenteditable` back down to its component pieces, such as intention events, cursor support, and more. But they are very nascent.\r\n\r\n### CSP\r\n\r\nUseful, provides control over behavior previously reserved to the UA (good!) but needs an API\r\n\r\n### AppCache\r\n\r\nGetting help. Has been sent to summer school.\r\n\r\n### Scrolling\r\n\r\nScroll is fundamentally a native capability that works differently across platforms. Attempts to polyfill with JS require per-platform detection and implementation (not feasible in practice).\r\n\r\nHooks into the lifecycle help users perform actions together with scrolling, but they are currently too limited for some use-cases, such as pull-to-refresh and DOM replacement (like `NSTableView`).\r\n\r\nGlimmers of hope: Chrome's beforescroll proposal; iOS 8's better stuff; proposals to make scrolling an \"animation timeline\"\r\n\r\n### ARIA & a11y\r\n\r\nAccessibility engine is not exposed very well. E.g. `<figcaption>` is exposed to accessibility technologies as captions, but ARIA has no `role=\"caption\"`. There is no way to tell assistive technology certain things (\"you are on a manipulable range slider\"), or take intents from an assistive technology (\"move this slider left\") and make them work for your own custom controls.\r\n\r\nARIA is a closed vocabulary (ala HTML without Custom Elements).\r\n\r\nZoom levels -- difficult to to detect if the OS has been put into a mode that enables lower-fidelity pointer interactions. Browsers generally zoom and text gets larger, which is good, but this is detected by side effect in JS.\r\n\r\nHigh-contrast mode -- also detectable by side-effect but not available through an API. Many many hacks required for information that UA's are fully aware of. Should likely be exposed through both API and media query.\r\n\r\n### Sensors\r\n\r\nWe kind of have geolocation and some acces to cameras/mic's, getting ambient light, but not much else. We're slowly getting out of the trap of designing APIs around the assumption of a single sensor of each type. https://github.com/rwaldron/sensors/\r\n\r\nOne interesting example of extensible web principles in play is how device orientation is in some ways a higher-level API on top of a magnetometer (and other stuff). For example, Google Cardboard would ideally like to use the magnetometer API directly, so that low-cost magnets can act as a UI for interfacing with your cardboard VR headset. Instead they have to reverse-engineer the magnetometer's behavior from how the device appears to reorient (according to the device orientation API) when a magnet passes by it.\r\n\r\nHopeful: https://github.com/dglazkov/tubes/blob/master/API.md\r\n\r\n### Preload Scanner/Resource Priorities\r\n\r\nNot pluggable, not controllable, no ability to re-order, no ability to set policy a different way to engine built-ins, no ability to understand easily what's \"above the fold\". \r\n\r\n### Miscellaneous Native Element Capabilities\r\n\r\nThere are a variety of things that native elements can do that custom elements cannot, due to non-extensible mechanisms in the HTML Standard. We have mentioned some of the more important of these above, e.g. accessibility hooks or form submission. But there are many smaller things too. For example only certain elements can become disabled (which impacts user-facing behavior, the matching of the `:disabled` CSS pseudoselector, and more). Only certain elements can become \"active\" (CSS `:active`, and user-exposed), and there is no general way of knowing when this happens. Native elements have more control over how they are focusable.\r\n\r\n### The Event Loop\r\n\r\nHTML defines concepts of microtasks, tasks, and the enqueuing thereof. However, there is no way for developers to inspect these queues, hook into them, or even just use them directly without hacks like `Promise.resolve().then(doMyMicrotask)` (and [worse](https://github.com/YuzuJS/setImmediate#the-tricks)). Ideally developers would be able to monitor all entries into the event loop, to better implement things like [zones](https://github.com/btford/zone.js/) without having to monkey-patch every async API on the platform.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}